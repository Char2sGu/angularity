import { inject } from '@angular/core';
import {
  ThemeBuilder,
  ThemeBuilderContext,
  ThemeTokens,
} from '@angularity/theming';
import { Hct, TonalPalette } from '@material/material-color-utilities';

import { HctFormatter } from './hct-formatter.service';
import { SchemeMode } from './scheme.builder';

/**
 * Configuration for `SchemeStaticColorBuilder`.
 */
export interface SchemeStaticColorBuilderConfig {
  /**
   * Name of the static color, e.g. "success".
   */
  name: string;

  /**
   * Source/Seed color for the static color. Only the hue and chroma of this
   * color will be used.
   *
   * @remarks `Hct` is the color representation from `material-color-utilities`,
   * which consists of hue, chroma, and tone.
   *
   * @example
   *  ```ts
   *  import { Hct, argbFromHex } from '@material/material-color-utilities';
   *  Hct.fromInt(0xc2e7ff)
   *  Hct.fromInt(argbFromHex("#c2e7ff"))
   *  ```
   */
  source: Hct;

  /**
   * Mode of the scheme. Light or Dark.
   */
  mode: SchemeMode;
}

/**
 * Implementation of `ThemeBuilder` that generates hex color tokens for Material
 * Design static colors (aka. custom colors).
 *
 * @remarks
 * A static color consists of 4 roles. Suppose the name of the static color is
 * "success", then there will be "success", "on-success", "success-container",
 * and "on-success-container" roles.
 *
 * @remarks
 * A non-empty name must be assigned to this builder.
 * The name assigned to this builder will be used as the prefix
 * to the generated tokens. When the name is "scheme", the generated tokens will
 * be "scheme-success", "scheme-on-success", etc.
 *
 * @remarks
 * When assigned the same name with `SchemeBuilder`, this builder can supplement
 * additional static colors to the main color roles generated by `SchemeBuilder`.
 *
 * @see https://m3.material.io/styles/color/advanced/define-new-colors
 *
 * @example
 *  ```ts
 *  provideTheme(
 *    withThemeBuilder("scheme", SchemeBuilder, {
 *      type: SchemeTonalSpot,
 *      source: Hct.fromInt(0x33bdff),
 *      mode: SchemeMode.Light,
 *      contrast: SchemeContrastLevel.Standard,
 *    }),
 *    withThemeBuilder("scheme", SchemeStaticColorBuilder, {
 *      name: "success",
 *      source: Hct.fromInt(0x8cb84a),
 *      mode: SchemeMode.Light,
 *    }),
 *    withThemeBuilder("scheme", SchemeStaticColorBuilder, {
 *      name: "warning",
 *      source: Hct.fromInt(0xd6913e),
 *      mode: SchemeMode.Light,
 *    }),
 *  ),
 *  ```
 */
export class SchemeStaticColorBuilder
  implements ThemeBuilder<SchemeStaticColorBuilderConfig>
{
  protected hctFormatter = inject(HctFormatter);

  build(
    context: ThemeBuilderContext<SchemeStaticColorBuilderConfig>,
  ): ThemeTokens {
    const { name, config } = context;
    const palette = TonalPalette.fromHct(config.source);
    const tones = this.getStaticColorTones(config.mode);
    const format = (argb: number) =>
      this.hctFormatter.format(Hct.fromInt(argb));
    return {
      [`${name}-${config.name}`]: format(palette.tone(tones.color)),
      [`${name}-on-${config.name}`]: format(palette.tone(tones.onColor)),
      [`${name}-${config.name}-container`]: format(
        palette.tone(tones.colorContainer),
      ),
      [`${name}-on-${config.name}-container`]: format(
        palette.tone(tones.onColorContainer),
      ),
    };
  }

  protected getStaticColorTones(
    mode: SchemeMode,
  ): Record<
    'color' | 'onColor' | 'colorContainer' | 'onColorContainer',
    number
  > {
    // Values are copied from material-color-utilities
    // https://github.com/material-foundation/material-color-utilities/blob/ca894db8b6aebb2833f1805ae61573c92e3f1660/typescript/utils/theme_utils.ts#L120-L146
    switch (mode) {
      case SchemeMode.Light:
        return {
          color: 40,
          onColor: 100,
          colorContainer: 90,
          onColorContainer: 10,
        };
      case SchemeMode.Dark:
        return {
          color: 80,
          onColor: 20,
          colorContainer: 30,
          onColorContainer: 90,
        };
      default:
        throw new Error('Non-exhaustive match for mode');
    }
  }
}
